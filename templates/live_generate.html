<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Report Builder</title>
  <link rel="stylesheet" href="/static/styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  
  <!-- Add offline recovery system -->
  <script src="/static/js/offline-recovery.js"></script>
  
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: sans-serif;
    }
    .editor, .preview {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }
    .editor { border-right: 1px solid #ccc; }
    details {
      border: 1px solid #aaa;
      border-radius: 6px;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background-color: #f9f9f9;
    }
    summary {
      font-weight: bold;
      cursor: pointer;
      padding: 0.5rem;
      background-color: #eee;
      border-radius: 4px;
      user-select: none;
    }
    input, textarea, select {
      width: 100%;
      margin-top: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.5rem;
      font-size: 1rem;
    }
    label { display: block; margin-bottom: 0.5rem; }
    button {
      margin-top: 0.5rem;
      padding: 0.5rem 1rem;
    }
    pre {
      background: #f0f0f0;
      padding: 1rem;
      overflow-x: auto;
    }
    .severity-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      margin-left: 0.5rem;
    }
    .sev-green { background-color: green; }
    .sev-yellow { background-color: gold; color: black; }
    .sev-orange { background-color: orange; }
    .sev-red { background-color: red; }
    .checklist-item {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      border: 1px solid #ccc;
      padding: 0.25rem;
      border-radius: 5px;
      background: #fff;
    }
    .checklist-label { flex: 1; }
    #imagePreview {
      max-width: 100%;
      max-height: 200px;
      margin-top: 0.5rem;
      border: 1px solid #ccc;
    }
    #map {
      height: 300px;
      margin-bottom: 1rem;
    }
    #syncStatus {
      background: #222;
      color: white;
      padding: 0.5rem;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .camera-controls {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .camera-controls button {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    .capture-btn {
      background: #007bff;
      color: white;
    }
    .gallery-btn {
      background: #28a745;
      color: white;
    }
    .offline-indicator {
      background: #dc3545;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .online-indicator {
      background: #28a745;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .image-metadata {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.5rem;
    }
    .sync-queue-info {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }
    
    /* Enhanced Offline Recovery Status */
    .recovery-status-panel {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      display: none;
      animation: slideIn 0.3s ease;
    }
    
    .recovery-status-panel.visible {
      display: block;
    }
    
    .recovery-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.75rem;
      font-weight: bold;
    }
    
    .recovery-metrics {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
      font-size: 0.9rem;
    }
    
    .recovery-metric {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 0.75rem;
      text-align: center;
    }
    
    /* AI Analysis Panel Styles */
    .ai-analysis-panel {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      display: none;
      animation: slideIn 0.3s ease;
    }
    
    .ai-analysis-panel.visible {
      display: block;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    .ai-panel-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1rem;
      font-weight: bold;
    }
    
    .ai-metrics {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .ai-metric {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 0.75rem;
      text-align: center;
    }
    
    .ai-metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      margin-bottom: 0.25rem;
    }
    
    .ai-metric-label {
      font-size: 0.8rem;
      opacity: 0.9;
    }
    
    .ai-recommendations {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 1rem;
      margin-top: 1rem;
    }
    
    .ai-recommendations h4 {
      margin: 0 0 0.5rem 0;
      font-size: 1rem;
    }
    
    .ai-recommendation-item {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }
    
    .ai-recommendation-item:last-child {
      margin-bottom: 0;
    }
    
    .severity-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .ai-assist-toggle {
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
    }
    
    .ai-assist-toggle:hover {
      background: #2563eb;
      transform: translateY(-1px);
    }
    
    .ai-assist-toggle.active {
      background: #16a34a;
    }
    
    .processing-indicator {
      display: none;
      align-items: center;
      gap: 0.5rem;
      color: #6b7280;
      font-size: 0.8rem;
      margin-top: 0.5rem;
    }
    
    .processing-indicator.active {
      display: flex;
    }
    
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #e5e7eb;
      border-top: 2px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .panic-indicator {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: bold;
      margin-left: 0.5rem;
    }
    
    .panic-calm { background: #dcfce7; color: #166534; }
    .panic-concerned { background: #fef3c7; color: #92400e; }
    .panic-elevated { background: #fecaca; color: #991b1b; }
    .panic-critical { background: #dc2626; color: white; animation: blink 1s infinite; }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    .confidence-bar {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 2px;
      overflow: hidden;
      margin-top: 0.5rem;
    }
    
    .confidence-fill {
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      transition: width 0.5s ease;
    }

    /* GPS Enhancement Styles */
    .gps-status-panel {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      border-radius: 12px;
      padding: 1rem;
      margin-bottom: 1rem;
      animation: slideIn 0.3s ease;
    }

    .gps-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      font-weight: bold;
    }

    .gps-indicator {
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: bold;
      background: rgba(255, 255, 255, 0.2);
      animation: pulse 2s infinite;
    }

    .gps-indicator.locating {
      background: #f59e0b;
      animation: blink 1s infinite;
    }

    .gps-indicator.accurate {
      background: #10b981;
      animation: none;
    }

    .gps-indicator.low-accuracy {
      background: #f97316;
      animation: none;
    }

    .gps-indicator.error {
      background: #ef4444;
      animation: blink 1s infinite;
    }

    .gps-indicator.manual {
      background: #6b7280;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .gps-details {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 1rem;
      font-size: 0.9rem;
    }

    .gps-metric {
      background: rgba(255, 255, 255, 0.1);
      padding: 0.5rem;
      border-radius: 6px;
      text-align: center;
    }

    .gps-label {
      display: block;
      font-size: 0.75rem;
      opacity: 0.8;
      margin-bottom: 0.25rem;
    }

    .gps-value {
      font-weight: bold;
      font-size: 0.85rem;
    }

    .gps-controls {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    .gps-btn {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 120px;
    }

    .gps-btn.primary {
      background: #3b82f6;
      color: white;
    }

    .gps-btn.secondary {
      background: #10b981;
      color: white;
    }

    .gps-btn.tertiary {
      background: #6b7280;
      color: white;
    }

    .gps-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .gps-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .location-suggestions {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      max-height: 150px;
      overflow-y: auto;
      position: absolute;
      width: calc(100% - 2rem);
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .location-suggestion {
      padding: 0.75rem;
      cursor: pointer;
      border-bottom: 1px solid #f3f4f6;
      transition: background 0.2s ease;
    }

    .location-suggestion:hover {
      background: #f9fafb;
    }

    .location-suggestion:last-child {
      border-bottom: none;
    }

    .copy-btn {
      margin-left: 0.5rem;
      padding: 0.25rem 0.5rem;
      background: #6b7280;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .copy-btn:hover {
      background: #4b5563;
    }

    .gps-accuracy-display {
      background: #f3f4f6;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .accuracy-bar {
      width: 100%;
      height: 8px;
      background: #e5e7eb;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .accuracy-fill {
      height: 100%;
      background: linear-gradient(90deg, #ef4444, #f97316, #10b981);
      transition: width 0.5s ease;
      border-radius: 4px;
    }

    .accuracy-text {
      text-align: center;
      font-size: 0.9rem;
      color: #6b7280;
    }
    
    @media (max-width: 768px) {
      .ai-metrics, .recovery-metrics {
        grid-template-columns: 1fr;
      }
      
      .severity-controls {
        flex-direction: column;
        align-items: stretch;
      }

      .gps-details {
        grid-template-columns: 1fr;
        gap: 0.5rem;
      }
      
      .gps-controls {
        flex-direction: column;
      }
      
      .gps-btn {
        min-width: auto;
      }
    }
  </style>
  <script src="https://unpkg.com/idb-keyval@6/dist/idb-keyval-iife.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <div id="syncStatus">
    üîÑ Sync Status: <span id="connectionStatus">Checking...</span>
    <span id="queueStatus" class="offline-indicator" style="display: none;">Queue: 0 reports</span>
  </div>
  
  <div class="editor">
    <h2>üìù Edit Report</h2>

    <div class="sync-queue-info" id="syncInfo">
      <strong>üìä Sync Queue:</strong> <span id="queueCount">0</span> reports pending
      <button onclick="forceSyncQueue()" style="margin-left: 1rem; padding: 0.25rem 0.5rem;">üîÑ Force Sync</button>
    </div>

    <!-- Enhanced Recovery Status Panel -->
    <div class="recovery-status-panel" id="recoveryStatusPanel">
      <div class="recovery-header">
        <span>üõ°Ô∏è Recovery System</span>
        <div style="font-size: 0.8rem; opacity: 0.9;" id="recoveryStatusText">Monitoring...</div>
      </div>
      <div class="recovery-metrics" id="recoveryMetricsGrid">
        <div class="recovery-metric">
          <div><strong id="syncSuccessCount">0</strong></div>
          <div>Successful Syncs</div>
        </div>
        <div class="recovery-metric">
          <div><strong id="syncFailureCount">0</strong></div>
          <div>Failed Syncs</div>
        </div>
        <div class="recovery-metric">
          <div><strong id="recoveryQueueSize">0</strong></div>
          <div>Recovery Queue</div>
        </div>
      </div>
    </div>

    <!-- AI Analysis Panel -->
    <div class="ai-analysis-panel" id="aiAnalysisPanel">
      <div class="ai-panel-header">
        <span>üß† Edge AI Analysis</span>
        <div style="margin-left: auto; font-size: 0.8rem; opacity: 0.9;" id="aiProcessingTime">--ms</div>
      </div>
      
      <div class="ai-metrics">
        <div class="ai-metric">
          <div class="ai-metric-value" id="aiSeverityValue">--</div>
          <div class="ai-metric-label">AI Severity</div>
        </div>
        <div class="ai-metric">
          <div class="ai-metric-value" id="aiConfidenceValue">--%</div>
          <div class="ai-metric-label">Confidence</div>
        </div>
        <div class="ai-metric">
          <div class="ai-metric-value" id="aiPanicValue">CALM</div>
          <div class="ai-metric-label">Panic Level</div>
        </div>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <strong>Text Analysis:</strong>
        <span id="textAnalysisResult">No text analyzed yet</span>
        <span class="panic-indicator" id="panicIndicator" style="display: none;"></span>
      </div>
      
      <div class="confidence-bar">
        <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
      </div>
      
      <div class="ai-recommendations" id="aiRecommendations" style="display: none;">
        <h4>üí° AI Recommendations</h4>
        <div id="recommendationsList"></div>
      </div>
    </div>

    <!-- Enhanced GPS Incident Details Section -->
    <details open>
      <summary>üìç Incident Details & GPS</summary>
      
      <!-- GPS Status Panel -->
      <div class="gps-status-panel" id="gpsStatusPanel">
        <div class="gps-header">
          <span>üì° GPS Status</span>
          <span class="gps-indicator" id="gpsIndicator">üîç Locating...</span>
        </div>
        <div class="gps-details" id="gpsDetails">
          <div class="gps-metric">
            <span class="gps-label">Accuracy:</span>
            <span class="gps-value" id="gpsAccuracy">--</span>
          </div>
          <div class="gps-metric">
            <span class="gps-label">Last Update:</span>
            <span class="gps-value" id="gpsTimestamp">--</span>
          </div>
          <div class="gps-metric">
            <span class="gps-label">Source:</span>
            <span class="gps-value" id="gpsSource">--</span>
          </div>
        </div>
      </div>

      <!-- Enhanced GPS Controls -->
      <div class="gps-controls">
        <button onclick="captureHighAccuracyGPS()" class="gps-btn primary">
          üìç High-Accuracy GPS
        </button>
        <button onclick="captureQuickGPS()" class="gps-btn secondary">
          ‚ö° Quick GPS
        </button>
        <button onclick="useManualLocation()" class="gps-btn tertiary">
          ‚úèÔ∏è Manual Entry
        </button>
      </div>

      <label>Location:
        <input type="text" id="location" placeholder="Auto-detected or manual entry..." />
        <div class="location-suggestions" id="locationSuggestions" style="display: none;"></div>
      </label>

      <label>Coordinates (lat,lng):
        <input type="text" id="coordinates" placeholder="30.2672,-97.7431" readonly />
        <button type="button" onclick="copyCoordinates()" class="copy-btn">üìã Copy</button>
      </label>

      <!-- GPS Accuracy Visualization -->
      <div class="gps-accuracy-display" id="gpsAccuracyDisplay" style="display: none;">
        <div class="accuracy-bar">
          <div class="accuracy-fill" id="accuracyFill"></div>
        </div>
        <div class="accuracy-text">
          <span id="accuracyDescription">Determining accuracy...</span>
        </div>
      </div>

      <div id="map"></div>
      
      <label>Hazards:
        <input type="text" id="hazards" />
      </label>
      
      <label>Severity:
        <div class="severity-controls">
          <input type="number" id="severity" min="1" max="10" style="flex: 1;" />
          <button class="ai-assist-toggle" id="aiAssistToggle" onclick="toggleAIAssist()">
            üß† AI Assist
          </button>
        </div>
        <span id="severityBadge" class="severity-badge"></span>
        <div class="processing-indicator" id="severityProcessing">
          <div class="spinner"></div>
          <span>AI calculating severity...</span>
        </div>
      </label>
      
      <label>Notes:
        <textarea id="notes" rows="3"></textarea>
        <div class="processing-indicator" id="notesProcessing">
          <div class="spinner"></div>
          <span>Analyzing text for emergency indicators...</span>
        </div>
      </label>
    </details>

    <details open>
      <summary>‚úÖ Checklist</summary>
      <label>Checklist Items (comma separated):
        <input type="text" id="checklist" />
      </label>
      <div id="checklistDisplay"></div>
    </details>

    <details open>
      <summary>üì∏ Hazard Images & Camera</summary>
      
      <!-- Camera Controls for Mobile/PWA -->
      <div class="camera-controls">
        <button class="capture-btn" onclick="capturePhoto()">üì∏ Take Photo</button>
        <button class="gallery-btn" onclick="selectFromGallery()">üñºÔ∏è From Gallery</button>
      </div>

      <!-- Hidden inputs for different capture methods -->
      <input type="file" id="camera_capture" accept="image/*" capture="environment" style="display: none;" />
      <input type="file" id="gallery_select" accept="image/*" style="display: none;" />
      
      <label>Image URL (optional):
        <input type="text" id="image_url" />
      </label>
      
      <img id="imagePreview" src="" alt="Image preview" style="display: none;" />
      <div id="imageMetadata" class="image-metadata"></div>
    </details>

    <button onclick="saveAndSyncReport()">üíæ Save & Sync Report</button>
    <button onclick="saveOfflineReport()">üì¥ Save Offline Only</button>
  </div>

  <div class="preview">
    <h2>üìÑ Live JSON Preview</h2>
    <pre id="jsonPreview"></pre>
    <h2>üìÑ PDF Preview</h2>
    <iframe id="pdfFrame" title="Live PDF" width="100%" height="400px"></iframe>
  </div>

  <!-- Load Edge AI Engine -->
  <script src="/static/js/edge-ai.js"></script>

  <script>
    const inputs = ["location", "coordinates", "hazards", "severity", "notes", "image_url", "checklist"];
    const teamMembers = ["Unassigned", "Fire Chief", "Medic", "Safety Officer", "Search & Rescue"];

    let map, marker;
    let currentImageBlob = null;
    let currentImageMetadata = null;
    let aiAssistEnabled = true;
    let analysisTimeout = null;
    let currentAIAnalysis = null;

    // GPS Enhancement Variables
    let currentPosition = null;
    let gpsWatchId = null;
    let gpsAccuracyThreshold = 50; // meters
    let lastGpsUpdate = null;

    // Edge AI Integration
    let aiImageAnalysis = null;
    let aiTextAnalysis = null;

    // GPS capture functions
    async function captureHighAccuracyGPS() {
      const btn = event.target;
      btn.disabled = true;
      btn.textContent = 'üìç Acquiring...';
      
      updateGpsStatus('locating', 'High-accuracy location...');
      
      const options = {
        enableHighAccuracy: true,
        timeout: 30000,
        maximumAge: 0
      };
      
      try {
        const position = await getCurrentPosition(options);
        await processGpsPosition(position, 'High-Accuracy GPS');
      } catch (error) {
        handleGpsError(error);
      } finally {
        btn.disabled = false;
        btn.textContent = 'üìç High-Accuracy GPS';
      }
    }

    async function captureQuickGPS() {
      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '‚ö° Locating...';
      
      updateGpsStatus('locating', 'Quick location...');
      
      const options = {
        enableHighAccuracy: false,
        timeout: 10000,
        maximumAge: 300000 // 5 minutes
      };
      
      try {
        const position = await getCurrentPosition(options);
        await processGpsPosition(position, 'Quick GPS');
      } catch (error) {
        handleGpsError(error);
      } finally {
        btn.disabled = false;
        btn.textContent = '‚ö° Quick GPS';
      }
    }

    function useManualLocation() {
      updateGpsStatus('manual', 'Manual entry mode');
      document.getElementById('location').readOnly = false;
      document.getElementById('coordinates').readOnly = false;
      document.getElementById('location').focus();
    }

    function getCurrentPosition(options) {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }
        
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }

    async function processGpsPosition(position, source) {
      currentPosition = position;
      lastGpsUpdate = new Date();
      
      const { latitude, longitude, accuracy } = position.coords;
      const timestamp = new Date(position.timestamp);
      
      // Update coordinates
      document.getElementById('coordinates').value = `${latitude.toFixed(6)},${longitude.toFixed(6)}`;
      
      // Update map marker
      if (marker) {
        marker.setLatLng([latitude, longitude]);
        map.setView([latitude, longitude], 15);
      }
      
      // Reverse geocode to get address
      try {
        const address = await reverseGeocode(latitude, longitude);
        document.getElementById('location').value = address;
      } catch (error) {
        document.getElementById('location').value = `Lat: ${latitude.toFixed(5)}, Lng: ${longitude.toFixed(5)}`;
      }
      
      // Update GPS status
      updateGpsDetails(accuracy, timestamp, source);
      updateAccuracyDisplay(accuracy);
      
      // Update AI context with location
      if (aiAssistEnabled && window.EdgeAI?.isLoaded) {
        updateAISeverityWithLocation({
          latitude,
          longitude,
          accuracy,
          timestamp: timestamp.toISOString()
        });
      }
      
      renderPreview();
    }

    async function reverseGeocode(lat, lng) {
      try {
        // Use a free geocoding service
        const response = await fetch(
          `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
          {
            headers: {
              'User-Agent': 'DisasterResponseApp/1.0'
            }
          }
        );
        
        if (response.ok) {
          const data = await response.json();
          return data.display_name || `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
        }
      } catch (error) {
        console.warn('Reverse geocoding failed:', error);
      }
      
      return `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
    }

    function updateGpsStatus(status, message) {
      const indicator = document.getElementById('gpsIndicator');
      indicator.className = `gps-indicator ${status}`;
      indicator.textContent = message;
    }

    function updateGpsDetails(accuracy, timestamp, source) {
      document.getElementById('gpsAccuracy').textContent = `¬±${Math.round(accuracy)}m`;
      document.getElementById('gpsTimestamp').textContent = timestamp.toLocaleTimeString();
      document.getElementById('gpsSource').textContent = source;
      
      // Update status based on accuracy
      if (accuracy <= 10) {
        updateGpsStatus('accurate', 'üéØ Excellent');
      } else if (accuracy <= 50) {
        updateGpsStatus('accurate', '‚úÖ Good');
      } else {
        updateGpsStatus('low-accuracy', '‚ö†Ô∏è Low Accuracy');
      }
    }

    function updateAccuracyDisplay(accuracy) {
      const display = document.getElementById('gpsAccuracyDisplay');
      const fill = document.getElementById('accuracyFill');
      const description = document.getElementById('accuracyDescription');
      
      display.style.display = 'block';
      
      // Calculate accuracy percentage (inverse - better accuracy = higher percentage)
      const maxAccuracy = 100; // meters
      const accuracyPercent = Math.max(0, Math.min(100, ((maxAccuracy - accuracy) / maxAccuracy) * 100));
      
      fill.style.width = `${accuracyPercent}%`;
      
      if (accuracy <= 5) {
        description.textContent = `Excellent GPS accuracy (¬±${Math.round(accuracy)}m) - Perfect for emergency response`;
      } else if (accuracy <= 15) {
        description.textContent = `Good GPS accuracy (¬±${Math.round(accuracy)}m) - Suitable for field operations`;
      } else if (accuracy <= 50) {
        description.textContent = `Moderate GPS accuracy (¬±${Math.round(accuracy)}m) - Consider high-accuracy mode`;
      } else {
        description.textContent = `Low GPS accuracy (¬±${Math.round(accuracy)}m) - Try high-accuracy GPS or manual entry`;
      }
    }

    function copyCoordinates() {
      const coords = document.getElementById('coordinates').value;
      if (coords) {
        navigator.clipboard.writeText(coords).then(() => {
          showToast('üìã Coordinates copied to clipboard!');
        }).catch(() => {
          // Fallback for older browsers
          const input = document.getElementById('coordinates');
          input.select();
          document.execCommand('copy');
          showToast('üìã Coordinates copied!');
        });
      }
    }

    function handleGpsError(error) {
      console.error('GPS Error:', error);
      
      let message = 'GPS unavailable';
      switch (error.code) {
        case error.PERMISSION_DENIED:
          message = '‚ùå Location access denied';
          break;
        case error.POSITION_UNAVAILABLE:
          message = '‚ùå GPS unavailable';
          break;
        case error.TIMEOUT:
          message = '‚è±Ô∏è GPS timeout';
          break;
      }
      
      updateGpsStatus('error', message);
      
      // Offer manual entry
      setTimeout(() => {
        if (confirm('GPS failed. Would you like to enter location manually?')) {
          useManualLocation();
        }
      }, 1000);
    }

    // Enhanced AI severity calculation with location context
    async function updateAISeverityWithLocation(gpsData) {
      if (!aiAssistEnabled || !window.EdgeAI?.isLoaded) return;

      const reportData = {
        text: document.getElementById('notes').value,
        image: currentImageBlob,
        context: {
          location: document.getElementById('location').value,
          coordinates: [gpsData.latitude, gpsData.longitude],
          gpsAccuracy: gpsData.accuracy,
          timestamp: gpsData.timestamp,
          hazards: document.getElementById('hazards').value,
          timeOfDay: new Date().getHours() > 18 || new Date().getHours() < 6 ? 'night' : 'day',
          // Add location-based risk factors
          locationRisk: calculateLocationRisk(gpsData.latitude, gpsData.longitude)
        }
      };

      try {
        const analysis = await window.EdgeAI.processReportRealTime(reportData);
        
        // Update severity with location-adjusted calculation
        if (analysis.severity && analysis.severity.overall) {
          const locationAdjustedSeverity = adjustSeverityForLocation(
            analysis.severity.overall, 
            reportData.context
          );
          
          document.getElementById('severity').value = locationAdjustedSeverity.toFixed(1);
          updateSeverityBadge();
        }
        
        displayAIAnalysis(analysis, analysis.processingTime || 0);
      } catch (error) {
        console.error('‚ùå AI analysis with location failed:', error);
      }
    }

    function calculateLocationRisk(lat, lng) {
      // Placeholder for location-based risk assessment
      // In production, this could check against:
      // - Known hazard zones
      // - Historical disaster data
      // - Infrastructure density
      // - Proximity to hospitals/fire stations
      
      return 'normal'; // normal, elevated, high
    }

    function adjustSeverityForLocation(baseSeverity, context) {
      let adjustedSeverity = baseSeverity;
      
      // Night time increases severity slightly
      if (context.timeOfDay === 'night') {
        adjustedSeverity += 0.5;
      }
      
      // Poor GPS accuracy might indicate remote location
      if (context.gpsAccuracy > 100) {
        adjustedSeverity += 0.3; // Remote areas are harder to reach
      }
      
      // Location risk adjustment
      if (context.locationRisk === 'high') {
        adjustedSeverity += 1.0;
      } else if (context.locationRisk === 'elevated') {
        adjustedSeverity += 0.5;
      }
      
      return Math.min(10, Math.max(1, adjustedSeverity));
    }

    function showToast(message, duration = 3000) {
      // Create or update toast notification
      let toast = document.getElementById('gpsToast');
      if (!toast) {
        toast = document.createElement('div');
        toast.id = 'gpsToast';
        toast.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #10b981;
          color: white;
          padding: 1rem;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
          z-index: 10000;
          animation: slideInRight 0.3s ease;
        `;
        document.body.appendChild(toast);
      }
      
      toast.textContent = message;
      toast.style.display = 'block';
      
      setTimeout(() => {
        if (toast && toast.parentNode) {
          toast.parentNode.removeChild(toast);
        }
      }, duration);
    }

    // IndexedDB Management for Images
    async function saveImageBlob(reportId, blob, metadata = {}) {
      try {
        await idbKeyval.set(`image_${reportId}`, blob);
        await idbKeyval.set(`image_meta_${reportId}`, {
          ...metadata,
          timestamp: new Date().toISOString(),
          size: blob.size,
          type: blob.type
        });
        console.log(`‚úÖ Image saved for report ${reportId}`);
        return true;
      } catch (error) {
        console.error('‚ùå Failed to save image blob:', error);
        return false;
      }
    }

    async function getImageBlob(reportId) {
      try {
        const blob = await idbKeyval.get(`image_${reportId}`);
        const metadata = await idbKeyval.get(`image_meta_${reportId}`);
        return { blob, metadata };
      } catch (error) {
        console.error('‚ùå Failed to retrieve image blob:', error);
        return { blob: null, metadata: null };
      }
    }

    async function deleteImageBlob(reportId) {
      try {
        await idbKeyval.del(`image_${reportId}`);
        await idbKeyval.del(`image_meta_${reportId}`);
        console.log(`üóëÔ∏è Image deleted for report ${reportId}`);
      } catch (error) {
        console.error('‚ùå Failed to delete image blob:', error);
      }
    }

    // AI Analysis Functions
    function toggleAIAssist() {
      aiAssistEnabled = !aiAssistEnabled;
      const toggle = document.getElementById('aiAssistToggle');
      
      if (aiAssistEnabled) {
        toggle.classList.add('active');
        toggle.textContent = 'üß† AI Assist ON';
        updateAISeverity();
      } else {
        toggle.classList.remove('active');
        toggle.textContent = 'üß† AI Assist OFF';
        hideAIAnalysis();
      }
    }

    async function updateAISeverity() {
      if (!aiAssistEnabled || !window.EdgeAI?.isLoaded) return;

      const reportData = collectFormData();
      
      // Show processing indicator
      const processingIndicator = document.getElementById('severityProcessing');
      processingIndicator.classList.add('active');

      try {
        const startTime = performance.now();
        
        // Perform comprehensive AI analysis
        currentAIAnalysis = await window.EdgeAI.processReportRealTime({
          text: reportData.notes,
          image: currentImageBlob,
          context: {
            location: reportData.location,
            hazards: reportData.hazards,
            timeOfDay: new Date().getHours() > 18 || new Date().getHours() < 6 ? 'night' : 'day'
          }
        });

        const processingTime = performance.now() - startTime;
        
        // Update severity field with AI recommendation
        if (currentAIAnalysis.severity && currentAIAnalysis.severity.overall) {
          const aiSeverity = Math.round(currentAIAnalysis.severity.overall * 10) / 10;
          document.getElementById('severity').value = aiSeverity;
          updateSeverityBadge();
        }

        // Display AI analysis
        displayAIAnalysis(currentAIAnalysis, processingTime);
        
        console.log('üß† AI severity calculation complete:', currentAIAnalysis);
      } catch (error) {
        console.error('‚ùå AI severity calculation failed:', error);
      } finally {
        processingIndicator.classList.remove('active');
      }
    }

    function displayAIAnalysis(analysis, processingTime) {
      const panel = document.getElementById('aiAnalysisPanel');
      panel.classList.add('visible');

      // Update processing time
      document.getElementById('aiProcessingTime').textContent = `${processingTime.toFixed(1)}ms`;

      // Update metrics
      if (analysis.severity) {
        document.getElementById('aiSeverityValue').textContent = analysis.severity.overall.toFixed(1);
        document.getElementById('aiConfidenceValue').textContent = `${Math.round(analysis.severity.confidence * 100)}%`;
        
        // Update confidence bar
        const confidenceFill = document.getElementById('confidenceFill');
        confidenceFill.style.width = `${analysis.severity.confidence * 100}%`;
      }

      // Update text analysis display
      if (analysis.textAnalysis) {
        const panicLevel = analysis.textAnalysis.panic_level;
        document.getElementById('aiPanicValue').textContent = panicLevel.toUpperCase();
        document.getElementById('textAnalysisResult').textContent = `Panic Level: ${panicLevel}`;
        
        // Show panic indicator
        const panicIndicator = document.getElementById('panicIndicator');
        panicIndicator.className = `panic-indicator panic-${panicLevel}`;
        panicIndicator.textContent = panicLevel.toUpperCase();
        panicIndicator.style.display = 'inline-block';
      }

      // Update recommendations
      if (analysis.recommendations && analysis.recommendations.length > 0) {
        const recommendationsDiv = document.getElementById('aiRecommendations');
        const recommendationsList = document.getElementById('recommendationsList');
        
        recommendationsList.innerHTML = analysis.recommendations.map(rec => 
          `<div class="ai-recommendation-item">
            <strong>${rec.priority}:</strong> ${rec.action}
          </div>`
        ).join('');
        
        recommendationsDiv.style.display = 'block';
      }
    }

    function hideAIAnalysis() {
      const panel = document.getElementById('aiAnalysisPanel');
      panel.classList.remove('visible');
    }

    // Text Analysis with Debouncing
    async function analyzeTextInput() {
      if (!aiAssistEnabled || !window.EdgeAI?.isLoaded) return;

      const text = document.getElementById('notes').value.trim();
      if (text.length < 10) {
        hideAIAnalysis();
        return;
      }

      // Show processing indicator
      const processingIndicator = document.getElementById('notesProcessing');
      processingIndicator.classList.add('active');

      // Clear previous timeout
      if (analysisTimeout) {
        clearTimeout(analysisTimeout);
      }

      // Debounce analysis
      analysisTimeout = setTimeout(async () => {
        try {
          aiTextAnalysis = window.EdgeAI.analyzeSentiment(text);
          await updateAISeverity(); // Recalculate severity with new text
        } catch (error) {
          console.error('‚ùå Text analysis failed:', error);
        } finally {
          processingIndicator.classList.remove('active');
        }
      }, 800);
    }

    // Image Analysis
    async function analyzeImageInput(file) {
      if (!aiAssistEnabled || !window.EdgeAI?.isLoaded || !file) return;

      try {
        // Create image element for analysis
        const img = new Image();
        img.onload = async () => {
          try {
            aiImageAnalysis = await window.EdgeAI.analyzeImage(img);
            await updateAISeverity(); // Recalculate severity with image data
            console.log('üì∑ Image AI analysis complete:', aiImageAnalysis);
          } catch (error) {
            console.error('‚ùå Image AI analysis failed:', error);
          }
        };
        img.src = URL.createObjectURL(file);
      } catch (error) {
        console.error('‚ùå Image analysis setup failed:', error);
      }
    }

    // Camera and Gallery Functions
    function capturePhoto() {
      const input = document.getElementById('camera_capture');
      input.click();
    }

    function selectFromGallery() {
      const input = document.getElementById('gallery_select');
      input.click();
    }

    async function handleImageSelection(file) {
      if (!file) return;

      currentImageBlob = file;
      currentImageMetadata = {
        filename: file.name,
        size: file.size,
        type: file.type,
        lastModified: file.lastModified
      };

      // Show preview
      const preview = document.getElementById('imagePreview');
      preview.src = URL.createObjectURL(file);
      preview.style.display = 'block';

      // Update metadata display
      updateImageMetadata();
      
      // Perform AI analysis
      await analyzeImageInput(file);
      
      // Update preview
      renderPreview();
    }

    function updateImageMetadata() {
      const metaDiv = document.getElementById('imageMetadata');
      if (currentImageMetadata) {
        const sizeKB = (currentImageMetadata.size / 1024).toFixed(1);
        metaDiv.innerHTML = `
          üìé <strong>${currentImageMetadata.filename}</strong><br>
          üìè Size: ${sizeKB} KB | Type: ${currentImageMetadata.type}<br>
          üì¥ <span style="color: orange;">Stored offline - will sync when online</span>
        `;
      } else {
        metaDiv.innerHTML = '';
      }
    }

    // Connection Status Management
    function updateConnectionStatus() {
      const statusSpan = document.getElementById('connectionStatus');
      const queueSpan = document.getElementById('queueStatus');
      
      if (navigator.onLine) {
        statusSpan.innerHTML = '<span class="online-indicator">üü¢ Online</span>';
        syncQueue(); // Auto-sync when back online
      } else {
        statusSpan.innerHTML = '<span class="offline-indicator">üî¥ Offline</span>';
      }
      
      updateQueueDisplay();
    }

    async function updateQueueDisplay() {
      const queue = await idbKeyval.get("sync_queue") || [];
      const queueCount = document.getElementById('queueCount');
      const queueStatus = document.getElementById('queueStatus');
      
      queueCount.textContent = queue.length;
      
      if (queue.length > 0) {
        queueStatus.style.display = 'inline';
        queueStatus.textContent = `Queue: ${queue.length} reports`;
      } else {
        queueStatus.style.display = 'none';
      }
      
      // Update recovery metrics if available
      if (window.offlineRecovery) {
        updateRecoveryMetricsDisplay(window.offlineRecovery.getMetrics());
      }
    }

    // Enhanced Recovery Metrics Display
    function updateRecoveryMetricsDisplay(metrics) {
      const panel = document.getElementById('recoveryStatusPanel');
      const statusText = document.getElementById('recoveryStatusText');
      const successCount = document.getElementById('syncSuccessCount');
      const failureCount = document.getElementById('syncFailureCount');
      const queueSize = document.getElementById('recoveryQueueSize');
      
      // Show panel if there are metrics to display
      const hasActivity = metrics.syncSuccesses > 0 || metrics.syncFailures > 0 || metrics.queueSize > 0;
      
      if (hasActivity) {
        panel.classList.add('visible');
        
        // Update status text
        if (metrics.queueSize > 5) {
          statusText.textContent = 'High queue volume';
          statusText.style.color = '#f59e0b';
        } else if (metrics.syncFailures > metrics.syncSuccesses && metrics.syncFailures > 0) {
          statusText.textContent = 'Recovery active';
          statusText.style.color = '#ef4444';
        } else if (metrics.isOnline && metrics.queueSize === 0) {
          statusText.textContent = 'All synced';
          statusText.style.color = '#10b981';
        } else {
          statusText.textContent = 'Monitoring...';
          statusText.style.color = 'white';
        }
        
        // Update metric values
        successCount.textContent = metrics.syncSuccesses;
        failureCount.textContent = metrics.syncFailures;
        queueSize.textContent = metrics.queueSize;
      } else {
        panel.classList.remove('visible');
      }
    }

    // Map Functions
    function initMap() {
      const coords = document.getElementById("coordinates").value.split(",").map(Number);
      const lat = coords[0] || 30.2672;
      const lng = coords[1] || -97.7431;

      map = L.map('map').setView([lat, lng], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      marker = L.marker([lat, lng], { draggable: true }).addTo(map);

      marker.on('dragend', () => {
        const pos = marker.getLatLng();
        const coordStr = `${pos.lat.toFixed(5)},${pos.lng.toFixed(5)}`;
        document.getElementById("coordinates").value = coordStr;
        document.getElementById("location").value = `Lat: ${pos.lat.toFixed(5)}, Lng: ${pos.lng.toFixed(5)}`;
        renderPreview();
      });
    }

    function getSeverityClass(sev) {
      if (sev >= 8) return "sev-red";
      if (sev >= 5) return "sev-orange";
      if (sev >= 3) return "sev-yellow";
      return "sev-green";
    }

    function updateSeverityBadge() {
      const val = parseFloat(document.getElementById("severity").value);
      const badge = document.getElementById("severityBadge");
      if (!isNaN(val)) {
        badge.textContent = "SEV-" + val.toFixed(1);
        badge.className = "severity-badge " + getSeverityClass(val);
      } else {
        badge.textContent = "";
        badge.className = "severity-badge";
      }
    }

    function renderChecklist() {
      const raw = document.getElementById("checklist").value;
      const items = raw.split(",").map(c => c.trim()).filter(Boolean);
      const container = document.getElementById("checklistDisplay");
      container.innerHTML = "";

      items.forEach(item => {
        const div = document.createElement("div");
        div.className = "checklist-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";

        const label = document.createElement("div");
        label.className = "checklist-label";
        label.textContent = item;

        const select = document.createElement("select");
        teamMembers.forEach(name => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        });

        div.appendChild(checkbox);
        div.appendChild(label);
        div.appendChild(select);
        container.appendChild(div);
      });
    }

    function updateImagePreview() {
      const urlInput = document.getElementById("image_url");
      const preview = document.getElementById("imagePreview");

      if (currentImageBlob) {
        // Priority to current blob
        return;
      } else if (urlInput.value) {
        preview.src = urlInput.value;
        preview.style.display = 'block';
        document.getElementById('imageMetadata').innerHTML = 'üåê <em>External URL image</em>';
      } else {
        preview.style.display = 'none';
        document.getElementById('imageMetadata').innerHTML = '';
      }
    }

    function collectFormData() {
      const checklistNodes = document.querySelectorAll(".checklist-item");
      const checklistData = Array.from(checklistNodes).map(div => ({
        item: div.querySelector(".checklist-label").textContent,
        completed: div.querySelector("input[type='checkbox']").checked,
        assigned_to: div.querySelector("select").value
      }));

      const reportId = crypto.randomUUID();
      let imageRef = null;

      if (currentImageBlob) {
        imageRef = `offline_blob://${reportId}`;
      } else if (document.getElementById("image_url").value) {
        imageRef = document.getElementById("image_url").value;
      }

      return {
        id: reportId,
        timestamp: new Date().toISOString(),
        location: document.getElementById("location").value,
        coordinates: document.getElementById("coordinates").value.split(",").map(Number),
        hazards: document.getElementById("hazards").value.split(",").map(h => h.trim()),
        severity: parseFloat(document.getElementById("severity").value),
        notes: document.getElementById("notes").value,
        image_url: imageRef,
        checklist: checklistData,
        has_offline_image: !!currentImageBlob,
        image_metadata: currentImageMetadata,
        ai_analysis: currentAIAnalysis, // Include AI analysis in report data
        gps_data: currentPosition ? {
          accuracy: currentPosition.coords.accuracy,
          timestamp: lastGpsUpdate?.toISOString(),
          source: document.getElementById('gpsSource').textContent
        } : null
      };
    }

    function renderPreview() {
      const data = collectFormData();
      document.getElementById("jsonPreview").textContent = JSON.stringify(data, null, 2);
    }

    // Enhanced Save Functions with Offline Recovery Integration
    async function saveOfflineReport() {
      try {
        const data = collectFormData();
        
        // Save image blob if exists
        if (currentImageBlob) {
          await saveImageBlob(data.id, currentImageBlob, currentImageMetadata);
        }

        // Save to local queue
        let queue = await idbKeyval.get("sync_queue") || [];
        queue.push(data);
        await idbKeyval.set("sync_queue", queue);

        // Notify recovery system of new offline report
        if (window.offlineRecovery) {
          window.offlineRecovery.updateSyncStatus();
          window.offlineRecovery.showNotification(
            'üì¥ Report saved offline - will sync when network returns', 
            'info'
          );
        } else {
          alert("üì¥ Report saved offline! Will sync when connected.");
        }
        
        updateQueueDisplay();
        renderPreview();
      } catch (error) {
        console.error('‚ùå Enhanced save offline failed:', error);
        
        // Show user-friendly error with recovery options
        if (window.offlineRecovery) {
          window.offlineRecovery.showNotification(
            '‚ùå Save failed - trying recovery methods...', 
            'error'
          );
          
          // Attempt emergency save
          await attemptEmergencySave();
        } else {
          alert('‚ùå Failed to save report offline. Please try again.');
        }
      }
    }

    async function saveAndSyncReport() {
      try {
        const data = collectFormData();
        
        // Check network status first
        if (!navigator.onLine && window.offlineRecovery) {
          console.log('üì¥ Network offline, using enhanced offline save');
          await saveOfflineReport();
          return;
        }
        
        // Save image blob if exists
        if (currentImageBlob) {
          await saveImageBlob(data.id, currentImageBlob, currentImageMetadata);
        }

        // Try enhanced sync with recovery
        const success = await attemptEnhancedSync(data);
        
        if (success) {
          if (window.offlineRecovery) {
            window.offlineRecovery.showNotification('‚úÖ Report uploaded successfully!', 'success');
          } else {
            alert('‚úÖ Report uploaded successfully!');
          }
        } else {
          // Fallback to offline save with recovery tracking
          console.log('‚ö†Ô∏è Sync failed, using enhanced offline save');
          await saveOfflineReport();
        }
        
      } catch (error) {
        console.error('‚ùå Enhanced save and sync failed:', error);
        
        // Emergency fallback
        await attemptEmergencySave();
      }
    }

    async function attemptEnhancedSync(data) {
      try {
        // Try primary sync method
        const success = await syncSingleReport(data);
        
        if (success) {
          return true;
        }
        
        // If primary fails and recovery system available, try recovery strategies
        if (window.offlineRecovery && window.offlineRecovery.recoveryStrategies) {
          console.log('üîß Primary sync failed, trying recovery strategies...');
          
          const recovered = await window.offlineRecovery.recoveryStrategies.attemptRecovery(data);
          
          if (recovered) {
            console.log('‚úÖ Recovery successful');
            return true;
          }
        }
        
        return false;
        
      } catch (error) {
        console.error('‚ùå Enhanced sync attempt failed:', error);
        return false;
      }
    }

    async function attemptEmergencySave() {
      try {
        const data = collectFormData();
        
        // Try multiple emergency save methods
        const emergencyMethods = [
          () => saveToLocalStorage(data),
          () => saveToIndexedDB(data),
          () => saveToSessionStorage(data),
          () => saveToCookies(data)
        ];
        
        for (const method of emergencyMethods) {
          try {
            await method();
            console.log('‚úÖ Emergency save successful');
            
            if (window.offlineRecovery) {
              window.offlineRecovery.showNotification(
                'üÜò Emergency save completed - data preserved!', 
                'warning'
              );
            } else {
              alert('üÜò Emergency save completed - data preserved!');
            }
            return;
          } catch (error) {
            console.warn('‚ö†Ô∏è Emergency method failed:', error);
          }
        }
        
        // If all methods fail
        console.error('‚ùå All emergency save methods failed');
        
        if (window.offlineRecovery) {
          window.offlineRecovery.showNotification(
            '‚ùå All save methods failed - please try again', 
            'error'
          );
        } else {
          alert('‚ùå All save methods failed - please try again');
        }
        
      } catch (error) {
        console.error('‚ùå Emergency save system failed:', error);
      }
    }

    function saveToLocalStorage(data) {
      const key = `emergency_report_${Date.now()}`;
      localStorage.setItem(key, JSON.stringify(data));
      console.log('üíæ Saved to localStorage:', key);
    }

    function saveToIndexedDB(data) {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('emergency_reports', 1);
        
        request.onerror = () => reject(request.error);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains('reports')) {
            db.createObjectStore('reports', { keyPath: 'id' });
          }
        };
        
        request.onsuccess = (event) => {
          const db = event.target.result;
          const transaction = db.transaction(['reports'], 'readwrite');
          const store = transaction.objectStore('reports');
          
          const addRequest = store.add({
            ...data,
            emergency_save: true,
            emergency_timestamp: Date.now()
          });
          
          addRequest.onsuccess = () => {
            console.log('üíæ Saved to IndexedDB emergency store');
            resolve();
          };
          
          addRequest.onerror = () => reject(addRequest.error);
        };
      });
    }

    function saveToSessionStorage(data) {
      const key = `session_emergency_${Date.now()}`;
      sessionStorage.setItem(key, JSON.stringify(data));
      console.log('üíæ Saved to sessionStorage:', key);
    }

    function saveToCookies(data) {
      // Only save essential data to cookies due to size limits
      const essentialData = {
        id: data.id,
        timestamp: data.timestamp,
        location: data.location,
        severity: data.severity,
        notes: data.notes.substring(0, 100) // Truncate for cookie size
      };
      
      const cookieValue = btoa(JSON.stringify(essentialData));
      document.cookie = `emergency_report_${Date.now()}=${cookieValue}; max-age=86400`; // 24 hours
      console.log('üç™ Saved essential data to cookies');
    }

    async function syncSingleReport(report) {
      try {
        // Use recovery system's enhanced sync if available
        if (window.offlineRecovery && window.offlineRecovery.syncSingleReport) {
          return await window.offlineRecovery.syncSingleReport(report);
        } else {
          // Fallback to original sync method
          const formData = new FormData();
          formData.append("json", JSON.stringify(report));
          
          if (report.has_offline_image) {
            const { blob } = await getImageBlob(report.id);
            if (blob) {
              formData.append("file", blob, report.image_metadata?.filename || "image.jpg");
            }
          }

          const response = await fetch("/generate-report", {
            method: "POST",
            body: formData
          });

          if (!response.ok) {
            throw new Error(`Sync failed: ${response.status}`);
          }

          // Clean up local image storage after successful sync
          if (report.has_offline_image) {
            await deleteImageBlob(report.id);
          }

          return true;
        }
      } catch (error) {
        console.error('‚ùå Enhanced single sync failed:', error);
        return false;
      }
    }

    async function syncQueue() {
      const queue = await idbKeyval.get("sync_queue") || [];
      if (queue.length === 0) return;

      const remaining = [];

      for (const report of queue) {
        try {
          const success = await syncSingleReport(report);
          if (success) {
            console.log(`‚úÖ Synced report: ${report.id}`);
          } else {
            remaining.push(report);
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to sync report ${report.id}:`, error);
          remaining.push(report);
        }
      }

      await idbKeyval.set("sync_queue", remaining);
      updateQueueDisplay();
    }

    async function forceSyncQueue() {
      if (!navigator.onLine) {
        if (window.offlineRecovery) {
          window.offlineRecovery.showNotification("‚ùå Cannot sync while offline!", 'error');
        } else {
          alert("‚ùå Cannot sync while offline!");
        }
        return;
      }

      const queue = await idbKeyval.get("sync_queue") || [];
      if (queue.length === 0) {
        if (window.offlineRecovery) {
          window.offlineRecovery.showNotification("‚úÖ No reports to sync!", 'success');
        } else {
          alert("‚úÖ No reports to sync!");
        }
        return;
      }

      await syncQueue();
      const remaining = await idbKeyval.get("sync_queue") || [];
      
      if (remaining.length === 0) {
        if (window.offlineRecovery) {
          window.offlineRecovery.showNotification("‚úÖ All reports synced successfully!", 'success');
        } else {
          alert("‚úÖ All reports synced successfully!");
        }
      } else {
        const message = `‚ö†Ô∏è ${remaining.length} reports failed to sync. Will retry automatically.`;
        if (window.offlineRecovery) {
          window.offlineRecovery.showNotification(message, 'warning');
        } else {
          alert(message);
        }
      }
    }

    // Legacy GPS function for compatibility
    async function autofillGPS() {
      await captureQuickGPS();
    }

    // Enhanced Network Status Management with Recovery Integration
    function updateNetworkStatusUI(online) {
      // Update existing sync status if it exists
      const statusSpan = document.getElementById('connectionStatus');
      if (statusSpan) {
        statusSpan.innerHTML = online ? 
          '<span class="online-indicator">üü¢ Online</span>' : 
          '<span class="offline-indicator">üî¥ Offline</span>';
      }
      
      // Update any offline-specific UI elements
      const offlineElements = document.querySelectorAll('.offline-only');
      const onlineElements = document.querySelectorAll('.online-only');
      
      offlineElements.forEach(el => el.style.display = online ? 'none' : 'block');
      onlineElements.forEach(el => el.style.display = online ? 'block' : 'none');
    }

    // Event Listeners
    window.addEventListener("online", () => {
      console.log('üü¢ Network online - updating UI');
      updateConnectionStatus();
      updateNetworkStatusUI(true);
    });

    window.addEventListener("offline", () => {
      console.log('üî¥ Network offline - updating UI');
      updateConnectionStatus();
      updateNetworkStatusUI(false);
    });

    // Listen for recovery system events
    window.addEventListener('recovery-complete', (event) => {
      console.log('üîÑ Recovery complete:', event.detail);
      updateQueueDisplay();
    });
    
    // Listen for sync status changes
    window.addEventListener('sync-status-changed', (event) => {
      console.log('üìä Sync status changed:', event.detail);
      updateQueueDisplay();
    });

    // Edge AI ready handler
    window.addEventListener('edgeai-ready', () => {
      console.log('üß† Edge AI ready for live report analysis');
      if (aiAssistEnabled) {
        updateAISeverity();
      }
    });

    // Image input handlers
    document.getElementById('camera_capture').addEventListener('change', (e) => {
      handleImageSelection(e.target.files[0]);
    });

    document.getElementById('gallery_select').addEventListener('change', (e) => {
      handleImageSelection(e.target.files[0]);
    });

    // Text analysis on notes input
    document.getElementById('notes').addEventListener('input', () => {
      analyzeTextInput();
    });

    // Severity manual change handler
    document.getElementById('severity').addEventListener('input', () => {
      updateSeverityBadge();
    });

    // Auto-capture GPS on page load
    window.addEventListener('load', () => {
      // Try quick GPS capture automatically
      setTimeout(() => {
        if (navigator.geolocation) {
          captureQuickGPS();
        } else {
          updateGpsStatus('error', '‚ùå GPS not supported');
          useManualLocation();
        }
      }, 1000);
    });

    // Initialize on load
    window.onload = () => {
      document.getElementById("location").value = "Austin, TX";
      document.getElementById("coordinates").value = "30.2672,-97.7431";
      document.getElementById("hazards").value = "fire, collapsed structure";
      document.getElementById("severity").value = "8.5";
      document.getElementById("notes").value = "Smoke observed, no visible injuries";
      document.getElementById("image_url").value = "https://via.placeholder.com/300";
      document.getElementById("checklist").value = "Clear debris, Search for victims";
      
      updateSeverityBadge();
      renderChecklist();
      updateImagePreview();
      renderPreview();
      initMap();
      updateConnectionStatus();
      updateQueueDisplay();

      // Initialize AI assist toggle
      const toggle = document.getElementById('aiAssistToggle');
      toggle.classList.add('active');
      toggle.textContent = 'üß† AI Assist ON';

      // Auto-sync every 30 seconds when online
      setInterval(() => {
        if (navigator.onLine) {
          syncQueue();
        }
      }, 30000);

      // Initial AI analysis if Edge AI is ready
      setTimeout(() => {
        if (window.EdgeAI?.isLoaded && aiAssistEnabled) {
          updateAISeverity();
        }
      }, 1000);

      // Initialize recovery monitoring if available
      if (window.offlineRecovery) {
        initializeRecoveryMonitoring();
      }
    };

    function initializeRecoveryMonitoring() {
      console.log('üì∂ Initializing recovery monitoring...');
      
      // Enhanced queue monitoring with recovery metrics
      const originalUpdateQueueDisplay = window.updateQueueDisplay;
      
      window.updateQueueDisplay = async function() {
        // Call original function
        if (originalUpdateQueueDisplay) {
          await originalUpdateQueueDisplay();
        } else {
          await updateQueueDisplay();
        }
        
        // Add recovery system metrics
        if (window.offlineRecovery) {
          const metrics = window.offlineRecovery.getMetrics();
          updateRecoveryMetricsDisplay(metrics);
        }
      };
      
      // Periodic recovery health check
      setInterval(async () => {
        if (window.offlineRecovery) {
          await window.offlineRecovery.updateSyncStatus();
          
          // Check for potential issues
          const metrics = window.offlineRecovery.getMetrics();
          
          if (metrics.syncFailures > 10) {
            console.warn('‚ö†Ô∏è High sync failure rate detected');
            window.offlineRecovery.showNotification(
              '‚ö†Ô∏è Multiple sync failures - check network connection', 
              'warning'
            );
          }
        }
      }, 30000); // Check every 30 seconds
    }

    inputs.forEach(id => {
      document.getElementById(id).addEventListener("input", () => {
        if (id === "checklist") renderChecklist();
        if (id === "image_url") updateImagePreview();
        if (id === "severity") updateSeverityBadge();
        if (id === "coordinates") {
          const [lat, lng] = document.getElementById("coordinates").value.split(",").map(Number);
          if (!isNaN(lat) && !isNaN(lng)) marker.setLatLng([lat, lng]);
        }
        
        // Trigger AI analysis for relevant fields
        if (aiAssistEnabled && (id === "notes" || id === "hazards" || id === "location")) {
          if (analysisTimeout) clearTimeout(analysisTimeout);
          analysisTimeout = setTimeout(() => {
            updateAISeverity();
          }, 1000);
        }
        
        renderPreview();
      });
    });

    // Register Service Worker for PWA capabilities
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/static/js/sw.js')
        .then(registration => {
          console.log('‚úÖ Service Worker registered:', registration);
        })
        .catch(error => {
          console.error('‚ùå Service Worker registration failed:', error);
        });
    }

    // Global debug functions for testing (enhanced with recovery system)
    window.OfflineDebug = {
      simulateOffline: () => {
        if (window.offlineRecovery) {
          window.offlineRecovery.startNetworkSimulation();
        } else {
          console.log('üî¥ Simulating offline mode...');
          Object.defineProperty(navigator, 'onLine', { value: false, writable: true });
          window.dispatchEvent(new Event('offline'));
        }
      },
      
      restoreOnline: () => {
        if (window.offlineRecovery) {
          window.offlineRecovery.stopNetworkSimulation();
        } else {
          console.log('üü¢ Restoring online mode...');
          Object.defineProperty(navigator, 'onLine', { value: true, writable: true });
          window.dispatchEvent(new Event('online'));
        }
      },
      
      runStressTest: () => {
        if (window.OfflineStressTesting) {
          return window.OfflineStressTesting.runStressTest();
        } else {
          console.log('üß™ Basic stress test - creating multiple reports...');
          for (let i = 0; i < 5; i++) {
            setTimeout(() => saveOfflineReport(), i * 100);
          }
        }
      },
      
      getMetrics: () => {
        if (window.offlineRecovery) {
          return window.offlineRecovery.getMetrics();
        } else {
          return {
            syncSuccesses: 0,
            syncFailures: 0,
            queueSize: 0,
            isOnline: navigator.onLine
          };
        }
      },
      
      forceRecovery: () => {
        if (window.offlineRecovery) {
          return window.offlineRecovery.attemptFullRecovery();
        } else {
          console.log('üîß Basic recovery - force syncing queue...');
          return forceSyncQueue();
        }
      },
      
      clearQueues: () => {
        if (window.offlineRecovery) {
          return window.offlineRecovery.clearQueue();
        } else {
          console.log('üóëÔ∏è Clearing local queue...');
          return idbKeyval.set("sync_queue", []).then(() => updateQueueDisplay());
        }
      }
    };

    console.log('üì∂ Enhanced Live Report Builder with Offline Recovery loaded');
    console.log('üß™ Use OfflineDebug.runStressTest() to test offline resilience');
    console.log('üìä Use OfflineDebug.getMetrics() to view recovery metrics');
    console.log('üîß Use OfflineDebug.forceRecovery() to trigger recovery process');
  </script>

  <!-- Enhanced integration with offline recovery system -->
  <script>
    // Enhanced integration with offline recovery system
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üì∂ Integrating offline recovery with live report builder...');
      
      // Wait for offline recovery to be ready
      if (window.offlineRecovery) {
        // Hook into existing save functions
        enhanceSaveFunctions();
        
        // Setup recovery event listeners
        setupRecoveryEventListeners();
        
        // Initialize recovery monitoring
        initializeRecoveryMonitoring();
        
        console.log('‚úÖ Offline recovery integration complete');
      } else {
        console.warn('‚ö†Ô∏è Offline recovery system not available');
        
        // Try again after a delay
        setTimeout(() => {
          if (window.offlineRecovery) {
            enhanceSaveFunctions();
            setupRecoveryEventListeners();
            initializeRecoveryMonitoring();
            console.log('‚úÖ Delayed offline recovery integration complete');
          }
        }, 2000);
      }
    });

    function enhanceSaveFunctions() {
      // Store original functions
      const originalSaveOfflineReport = window.saveOfflineReport;
      const originalSaveAndSyncReport = window.saveAndSyncReport;
      const originalSyncSingleReport = window.syncSingleReport;
      
      // Enhanced saveOfflineReport with recovery tracking
      window.saveOfflineReport = async function() {
        try {
          await originalSaveOfflineReport();
          
          // Notify recovery system of new offline report
          if (window.offlineRecovery) {
            window.offlineRecovery.updateSyncStatus();
          }
        } catch (error) {
          console.error('‚ùå Enhanced save offline failed:', error);
          
          // Show user-friendly error with recovery options
          if (window.offlineRecovery) {
            window.offlineRecovery.showNotification(
              '‚ùå Save failed - trying recovery methods...', 
              'error'
            );
            
            // Attempt emergency save
            await attemptEmergencySave();
          }
        }
      };
      
      // Enhanced saveAndSyncReport with advanced retry logic
      window.saveAndSyncReport = async function() {
        try {
          const data = collectFormData();
          
          // Check network status first
          if (!navigator.onLine && window.offlineRecovery) {
            console.log('üì¥ Network offline, using enhanced offline save');
            await saveOfflineReport();
            window.offlineRecovery.showNotification(
              'üì¥ Saved offline - will sync when network returns', 
              'info'
            );
            return;
          }
          
          // Try enhanced sync with recovery
          const success = await attemptEnhancedSync(data);
          
          if (success) {
            if (window.offlineRecovery) {
              window.offlineRecovery.showNotification('‚úÖ Report uploaded successfully!', 'success');
            } else {
              alert('‚úÖ Report uploaded successfully!');
            }
          } else {
            // Fallback to offline save with recovery tracking
            console.log('‚ö†Ô∏è Sync failed, using enhanced offline save');
            await saveOfflineReport();
          }
          
        } catch (error) {
          console.error('‚ùå Enhanced save and sync failed:', error);
          
          // Emergency fallback
          await attemptEmergencySave();
        }
      };
      
      // Enhanced syncSingleReport with conflict resolution
      window.syncSingleReport = async function(report) {
        try {
          // Use recovery system's enhanced sync if available
          if (window.offlineRecovery && window.offlineRecovery.syncSingleReport) {
            return await window.offlineRecovery.syncSingleReport(report);
          } else {
            return await originalSyncSingleReport(report);
          }
        } catch (error) {
          console.error('‚ùå Enhanced single sync failed:', error);
          return false;
        }
      };
    }

    function setupRecoveryEventListeners() {
      // Listen for network status changes
      window.addEventListener('online', () => {
        console.log('üü¢ Network online - updating UI');
        updateNetworkStatusUI(true);
      });

      window.addEventListener('offline', () => {
        console.log('üî¥ Network offline - updating UI');
        updateNetworkStatusUI(false);
      });
      
      // Listen for recovery system events
      window.addEventListener('recovery-complete', (event) => {
        console.log('üîÑ Recovery complete:', event.detail);
        updateQueueDisplay();
      });
      
      // Listen for sync status changes
      window.addEventListener('sync-status-changed', (event) => {
        console.log('üìä Sync status changed:', event.detail);
        updateQueueDisplay();
      });
    }

    console.log('üì∂ Offline recovery integration loaded');
  </script>
</body>
</html>