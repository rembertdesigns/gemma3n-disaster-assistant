<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Live Report Builder</title>
  <link rel="stylesheet" href="/static/styles.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      font-family: sans-serif;
    }
    .editor, .preview {
      flex: 1;
      padding: 1rem;
      overflow-y: auto;
    }
    .editor { border-right: 1px solid #ccc; }
    details {
      border: 1px solid #aaa;
      border-radius: 6px;
      margin-bottom: 1rem;
      padding: 0.5rem;
      background-color: #f9f9f9;
    }
    summary {
      font-weight: bold;
      cursor: pointer;
      padding: 0.5rem;
      background-color: #eee;
      border-radius: 4px;
      user-select: none;
    }
    input, textarea, select {
      width: 100%;
      margin-top: 0.5rem;
      margin-bottom: 1rem;
      padding: 0.5rem;
      font-size: 1rem;
    }
    label { display: block; margin-bottom: 0.5rem; }
    button {
      margin-top: 0.5rem;
      padding: 0.5rem 1rem;
    }
    pre {
      background: #f0f0f0;
      padding: 1rem;
      overflow-x: auto;
    }
    .severity-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      margin-left: 0.5rem;
    }
    .sev-green { background-color: green; }
    .sev-yellow { background-color: gold; color: black; }
    .sev-orange { background-color: orange; }
    .sev-red { background-color: red; }
    .checklist-item {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      border: 1px solid #ccc;
      padding: 0.25rem;
      border-radius: 5px;
      background: #fff;
    }
    .checklist-label { flex: 1; }
    #imagePreview {
      max-width: 100%;
      max-height: 200px;
      margin-top: 0.5rem;
      border: 1px solid #ccc;
    }
    #map {
      height: 300px;
      margin-bottom: 1rem;
    }
    #syncStatus {
      background: #222;
      color: white;
      padding: 0.5rem;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    .camera-controls {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .camera-controls button {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
    }
    .capture-btn {
      background: #007bff;
      color: white;
    }
    .gallery-btn {
      background: #28a745;
      color: white;
    }
    .offline-indicator {
      background: #dc3545;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .online-indicator {
      background: #28a745;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }
    .image-metadata {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.5rem;
    }
    .sync-queue-info {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      padding: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.9rem;
    }
  </style>
  <script src="https://unpkg.com/idb-keyval@6/dist/idb-keyval-iife.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <div id="syncStatus">
    üîÑ Sync Status: <span id="connectionStatus">Checking...</span>
    <span id="queueStatus" class="offline-indicator" style="display: none;">Queue: 0 reports</span>
  </div>
  
  <div class="editor">
    <h2>üìù Edit Report</h2>

    <div class="sync-queue-info" id="syncInfo">
      <strong>üìä Sync Queue:</strong> <span id="queueCount">0</span> reports pending
      <button onclick="forceSyncQueue()" style="margin-left: 1rem; padding: 0.25rem 0.5rem;">üîÑ Force Sync</button>
    </div>

    <details open>
      <summary>üìç Incident Details</summary>
      <button onclick="autofillGPS()">üìç Auto-Fill Location</button>
      <label>Location:
        <input type="text" id="location" />
      </label>
      <label>Coordinates (lat,lng):
        <input type="text" id="coordinates" placeholder="30.2672,-97.7431" />
      </label>
      <div id="map"></div>
      <label>Hazards:
        <input type="text" id="hazards" />
      </label>
      <label>Severity:
        <input type="number" id="severity" min="1" max="10" />
        <span id="severityBadge" class="severity-badge"></span>
      </label>
      <label>Notes:
        <textarea id="notes" rows="3"></textarea>
      </label>
    </details>

    <details open>
      <summary>‚úÖ Checklist</summary>
      <label>Checklist Items (comma separated):
        <input type="text" id="checklist" />
      </label>
      <div id="checklistDisplay"></div>
    </details>

    <details open>
      <summary>üì∏ Hazard Images & Camera</summary>
      
      <!-- Camera Controls for Mobile/PWA -->
      <div class="camera-controls">
        <button class="capture-btn" onclick="capturePhoto()">üì∏ Take Photo</button>
        <button class="gallery-btn" onclick="selectFromGallery()">üñºÔ∏è From Gallery</button>
      </div>

      <!-- Hidden inputs for different capture methods -->
      <input type="file" id="camera_capture" accept="image/*" capture="environment" style="display: none;" />
      <input type="file" id="gallery_select" accept="image/*" style="display: none;" />
      
      <label>Image URL (optional):
        <input type="text" id="image_url" />
      </label>
      
      <img id="imagePreview" src="" alt="Image preview" style="display: none;" />
      <div id="imageMetadata" class="image-metadata"></div>
    </details>

    <button onclick="saveAndSyncReport()">üíæ Save & Sync Report</button>
    <button onclick="saveOfflineReport()">üì¥ Save Offline Only</button>
  </div>

  <div class="preview">
    <h2>üìÑ Live JSON Preview</h2>
    <pre id="jsonPreview"></pre>
    <h2>üìÑ PDF Preview</h2>
    <iframe id="pdfFrame" title="Live PDF" width="100%" height="400px"></iframe>
  </div>

  <script>
    const inputs = ["location", "coordinates", "hazards", "severity", "notes", "image_url", "checklist"];
    const teamMembers = ["Unassigned", "Fire Chief", "Medic", "Safety Officer", "Search & Rescue"];

    let map, marker;
    let currentImageBlob = null;
    let currentImageMetadata = null;

    // IndexedDB Management for Images
    async function saveImageBlob(reportId, blob, metadata = {}) {
      try {
        await idbKeyval.set(`image_${reportId}`, blob);
        await idbKeyval.set(`image_meta_${reportId}`, {
          ...metadata,
          timestamp: new Date().toISOString(),
          size: blob.size,
          type: blob.type
        });
        console.log(`‚úÖ Image saved for report ${reportId}`);
        return true;
      } catch (error) {
        console.error('‚ùå Failed to save image blob:', error);
        return false;
      }
    }

    async function getImageBlob(reportId) {
      try {
        const blob = await idbKeyval.get(`image_${reportId}`);
        const metadata = await idbKeyval.get(`image_meta_${reportId}`);
        return { blob, metadata };
      } catch (error) {
        console.error('‚ùå Failed to retrieve image blob:', error);
        return { blob: null, metadata: null };
      }
    }

    async function deleteImageBlob(reportId) {
      try {
        await idbKeyval.del(`image_${reportId}`);
        await idbKeyval.del(`image_meta_${reportId}`);
        console.log(`üóëÔ∏è Image deleted for report ${reportId}`);
      } catch (error) {
        console.error('‚ùå Failed to delete image blob:', error);
      }
    }

    // Camera and Gallery Functions
    function capturePhoto() {
      const input = document.getElementById('camera_capture');
      input.click();
    }

    function selectFromGallery() {
      const input = document.getElementById('gallery_select');
      input.click();
    }

    async function handleImageSelection(file) {
      if (!file) return;

      currentImageBlob = file;
      currentImageMetadata = {
        filename: file.name,
        size: file.size,
        type: file.type,
        lastModified: file.lastModified
      };

      // Show preview
      const preview = document.getElementById('imagePreview');
      preview.src = URL.createObjectURL(file);
      preview.style.display = 'block';

      // Update metadata display
      updateImageMetadata();
      
      // Update preview
      renderPreview();
    }

    function updateImageMetadata() {
      const metaDiv = document.getElementById('imageMetadata');
      if (currentImageMetadata) {
        const sizeKB = (currentImageMetadata.size / 1024).toFixed(1);
        metaDiv.innerHTML = `
          üìé <strong>${currentImageMetadata.filename}</strong><br>
          üìè Size: ${sizeKB} KB | Type: ${currentImageMetadata.type}<br>
          üì¥ <span style="color: orange;">Stored offline - will sync when online</span>
        `;
      } else {
        metaDiv.innerHTML = '';
      }
    }

    // Connection Status Management
    function updateConnectionStatus() {
      const statusSpan = document.getElementById('connectionStatus');
      const queueSpan = document.getElementById('queueStatus');
      
      if (navigator.onLine) {
        statusSpan.innerHTML = '<span class="online-indicator">üü¢ Online</span>';
        syncQueue(); // Auto-sync when back online
      } else {
        statusSpan.innerHTML = '<span class="offline-indicator">üî¥ Offline</span>';
      }
      
      updateQueueDisplay();
    }

    async function updateQueueDisplay() {
      const queue = await idbKeyval.get("sync_queue") || [];
      const queueCount = document.getElementById('queueCount');
      const queueStatus = document.getElementById('queueStatus');
      
      queueCount.textContent = queue.length;
      
      if (queue.length > 0) {
        queueStatus.style.display = 'inline';
        queueStatus.textContent = `Queue: ${queue.length} reports`;
      } else {
        queueStatus.style.display = 'none';
      }
    }

    // Map Functions
    function initMap() {
      const coords = document.getElementById("coordinates").value.split(",").map(Number);
      const lat = coords[0] || 30.2672;
      const lng = coords[1] || -97.7431;

      map = L.map('map').setView([lat, lng], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      marker = L.marker([lat, lng], { draggable: true }).addTo(map);

      marker.on('dragend', () => {
        const pos = marker.getLatLng();
        const coordStr = `${pos.lat.toFixed(5)},${pos.lng.toFixed(5)}`;
        document.getElementById("coordinates").value = coordStr;
        document.getElementById("location").value = `Lat: ${pos.lat.toFixed(5)}, Lng: ${pos.lng.toFixed(5)}`;
        renderPreview();
      });
    }

    function getSeverityClass(sev) {
      if (sev >= 8) return "sev-red";
      if (sev >= 5) return "sev-orange";
      if (sev >= 3) return "sev-yellow";
      return "sev-green";
    }

    function updateSeverityBadge() {
      const val = parseFloat(document.getElementById("severity").value);
      const badge = document.getElementById("severityBadge");
      if (!isNaN(val)) {
        badge.textContent = "SEV-" + val.toFixed(1);
        badge.className = "severity-badge " + getSeverityClass(val);
      } else {
        badge.textContent = "";
        badge.className = "severity-badge";
      }
    }

    function renderChecklist() {
      const raw = document.getElementById("checklist").value;
      const items = raw.split(",").map(c => c.trim()).filter(Boolean);
      const container = document.getElementById("checklistDisplay");
      container.innerHTML = "";

      items.forEach(item => {
        const div = document.createElement("div");
        div.className = "checklist-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";

        const label = document.createElement("div");
        label.className = "checklist-label";
        label.textContent = item;

        const select = document.createElement("select");
        teamMembers.forEach(name => {
          const opt = document.createElement("option");
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        });

        div.appendChild(checkbox);
        div.appendChild(label);
        div.appendChild(select);
        container.appendChild(div);
      });
    }

    function updateImagePreview() {
      const urlInput = document.getElementById("image_url");
      const preview = document.getElementById("imagePreview");

      if (currentImageBlob) {
        // Priority to current blob
        return;
      } else if (urlInput.value) {
        preview.src = urlInput.value;
        preview.style.display = 'block';
        document.getElementById('imageMetadata').innerHTML = 'üåê <em>External URL image</em>';
      } else {
        preview.style.display = 'none';
        document.getElementById('imageMetadata').innerHTML = '';
      }
    }

    function collectFormData() {
      const checklistNodes = document.querySelectorAll(".checklist-item");
      const checklistData = Array.from(checklistNodes).map(div => ({
        item: div.querySelector(".checklist-label").textContent,
        completed: div.querySelector("input[type='checkbox']").checked,
        assigned_to: div.querySelector("select").value
      }));

      const reportId = crypto.randomUUID();
      let imageRef = null;

      if (currentImageBlob) {
        imageRef = `offline_blob://${reportId}`;
      } else if (document.getElementById("image_url").value) {
        imageRef = document.getElementById("image_url").value;
      }

      return {
        id: reportId,
        timestamp: new Date().toISOString(),
        location: document.getElementById("location").value,
        coordinates: document.getElementById("coordinates").value.split(",").map(Number),
        hazards: document.getElementById("hazards").value.split(",").map(h => h.trim()),
        severity: parseFloat(document.getElementById("severity").value),
        notes: document.getElementById("notes").value,
        image_url: imageRef,
        checklist: checklistData,
        has_offline_image: !!currentImageBlob,
        image_metadata: currentImageMetadata
      };
    }

    function renderPreview() {
      const data = collectFormData();
      document.getElementById("jsonPreview").textContent = JSON.stringify(data, null, 2);
    }

    // Save Functions
    async function saveOfflineReport() {
      const data = collectFormData();
      
      // Save image blob if exists
      if (currentImageBlob) {
        await saveImageBlob(data.id, currentImageBlob, currentImageMetadata);
      }

      // Save to local queue
      let queue = await idbKeyval.get("sync_queue") || [];
      queue.push(data);
      await idbKeyval.set("sync_queue", queue);

      alert("üì¥ Report saved offline! Will sync when connected.");
      updateQueueDisplay();
      renderPreview();
    }

    async function saveAndSyncReport() {
      const data = collectFormData();
      
      // Save image blob if exists
      if (currentImageBlob) {
        await saveImageBlob(data.id, currentImageBlob, currentImageMetadata);
      }

      if (navigator.onLine) {
        // Try immediate sync
        try {
          await syncSingleReport(data);
          alert("‚úÖ Report uploaded successfully!");
        } catch (error) {
          // Fall back to offline queue
          console.warn('Sync failed, saving offline:', error);
          await saveOfflineReport();
        }
      } else {
        // Save offline
        await saveOfflineReport();
      }
    }

    async function syncSingleReport(report) {
      const formData = new FormData();
      formData.append("json", JSON.stringify(report));
      
      if (report.has_offline_image) {
        const { blob } = await getImageBlob(report.id);
        if (blob) {
          formData.append("file", blob, report.image_metadata?.filename || "image.jpg");
        }
      }

      const response = await fetch("/generate-report", {
        method: "POST",
        body: formData
      });

      if (!response.ok) {
        throw new Error(`Sync failed: ${response.status}`);
      }

      // Clean up local image storage after successful sync
      if (report.has_offline_image) {
        await deleteImageBlob(report.id);
      }

      return response;
    }

    async function syncQueue() {
      const queue = await idbKeyval.get("sync_queue") || [];
      if (queue.length === 0) return;

      const remaining = [];

      for (const report of queue) {
        try {
          await syncSingleReport(report);
          console.log(`‚úÖ Synced report: ${report.id}`);
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to sync report ${report.id}:`, error);
          remaining.push(report);
        }
      }

      await idbKeyval.set("sync_queue", remaining);
      updateQueueDisplay();
    }

    async function forceSyncQueue() {
      if (!navigator.onLine) {
        alert("‚ùå Cannot sync while offline!");
        return;
      }

      const queue = await idbKeyval.get("sync_queue") || [];
      if (queue.length === 0) {
        alert("‚úÖ No reports to sync!");
        return;
      }

      await syncQueue();
      const remaining = await idbKeyval.get("sync_queue") || [];
      
      if (remaining.length === 0) {
        alert("‚úÖ All reports synced successfully!");
      } else {
        alert(`‚ö†Ô∏è ${remaining.length} reports failed to sync. Will retry automatically.`);
      }
    }

    async function autofillGPS() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported.");
        return;
      }

      navigator.geolocation.getCurrentPosition(pos => {
        const lat = pos.coords.latitude.toFixed(5);
        const lng = pos.coords.longitude.toFixed(5);
        document.getElementById("coordinates").value = `${lat},${lng}`;
        document.getElementById("location").value = `Lat: ${lat}, Lng: ${lng}`;
        marker.setLatLng([lat, lng]);
        map.setView([lat, lng], 13);
        renderPreview();
      }, err => {
        alert("Failed to get GPS location.");
        console.error(err);
      });
    }

    // Event Listeners
    window.addEventListener("online", () => {
      updateConnectionStatus();
    });

    window.addEventListener("offline", () => {
      updateConnectionStatus();
    });

    // Image input handlers
    document.getElementById('camera_capture').addEventListener('change', (e) => {
      handleImageSelection(e.target.files[0]);
    });

    document.getElementById('gallery_select').addEventListener('change', (e) => {
      handleImageSelection(e.target.files[0]);
    });

    // Initialize on load
    window.onload = () => {
      document.getElementById("location").value = "Austin, TX";
      document.getElementById("coordinates").value = "30.2672,-97.7431";
      document.getElementById("hazards").value = "fire, collapsed structure";
      document.getElementById("severity").value = "8.5";
      document.getElementById("notes").value = "Smoke observed, no visible injuries";
      document.getElementById("image_url").value = "https://via.placeholder.com/300";
      document.getElementById("checklist").value = "Clear debris, Search for victims";
      
      updateSeverityBadge();
      renderChecklist();
      updateImagePreview();
      renderPreview();
      initMap();
      updateConnectionStatus();
      updateQueueDisplay();

      // Auto-sync every 30 seconds when online
      setInterval(() => {
        if (navigator.onLine) {
          syncQueue();
        }
      }, 30000);
    };

    inputs.forEach(id => {
      document.getElementById(id).addEventListener("input", () => {
        if (id === "checklist") renderChecklist();
        if (id === "image_url") updateImagePreview();
        if (id === "severity") updateSeverityBadge();
        if (id === "coordinates") {
          const [lat, lng] = document.getElementById("coordinates").value.split(",").map(Number);
          if (!isNaN(lat) && !isNaN(lng)) marker.setLatLng([lat, lng]);
        }
        renderPreview();
      });
    });

    // Register Service Worker for PWA capabilities
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/static/js/sw.js')
        .then(registration => {
          console.log('‚úÖ Service Worker registered:', registration);
        })
        .catch(error => {
          console.error('‚ùå Service Worker registration failed:', error);
        });
    }
  </script>
</body>
</html>